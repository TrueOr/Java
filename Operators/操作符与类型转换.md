## 操作符
### 按位操作符
按位运算符是来操作整数基本数据类型中的单个“比特”(bir)，即二进制位，位运算符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。<br>
#### “与”、“位与”（&）
按位“与”操作符，如果两个数的二进制，相同位数都是1，则该位结果是1，否则是0.
> 5&4<br>
> 5的二进制是  00000000 00000000 00000000 00000101<br>
> 4的二进制是  00000000 00000000 00000000 00000100<br>
> 结果是       00000000 00000000 00000000 00000100 转为十进制是4。

#### “或”、“位或”（|）
按位“或”操作符，如果两个数的二进制，相同位数有一个是1，则该位结果是1，否则是0
> 5 | 4<br>
> 5的二进制是  00000000 00000000 00000000 00000101<br>
> 4的二进制是  00000000 00000000 00000000 00000100<br>
> 结果是       00000000 00000000 00000000 00000101  转为十进制是5。

#### “异或、“位异或”（^）
按位“异或”操作符，如果两个数的二进制，相同位数只有一个是1，则该位结果是1，否则是0
> 5 ^ 4<br>
> 5的二进制是  00000000 00000000 00000000 00000101<br>
> 4的二进制是  00000000 00000000 00000000 00000100<br>
> 结果是       00000000 00000000 00000000 00000001 转为十进制是1。

#### “非”、“位非”（~）也称为取反操作符
按位“非”操作符，属于一元操作符，只对一个操作数进行操作，（其他按位操作符是二元操作符）。
按位“非”生成与输入位相反的值，若输入0，则输出1，若输入1，则输出0。
> ~5<br>
> 5的二进制是  00000000 00000000 00000000 00000101<br>
> 则~5是       11111111 11111111 11111111 11111010  转为十进制是 -6。

#### 负数的二进制表达方式
电脑的的世界中只有0和1，那么负数怎么表示呢？
二进制的正负是从高位看，最高位如果1则是负数，如果是0则是正数。
如果负数单纯是把最高位变为1的话，在运算中会出现不是我们想要的值，
所以引入了：原码，反码，补码。正数的原码，反码，补码都一样。负数的反码是对除了符号位（最高位）对原码取反，补码是对反码+1,
负数的二进制转化，计算机计算是用的补码<br>
> 1、首先取出这个数的原码的二进制，<br>
> 2、然后再求出反码<br>
> 3、最后求出补码<br>

> -5<br>
> -5的原码是                10000000 00000000 00000000 00000101<br>
> 求出反码的是              11111111 11111111 11111111 11111010<br>
> 求出补码是                11111111 11111111 11111111 11111011

### 移位操作符
移位操作符操作的运算对象也是二进制的“位”,移位操作符只可用来处理整数类型。<br>
左移位操作符（<<）能按照操作符右侧指定的位数将操作符左边的操作数向左移动（在低位补0）<br>
“有符号”右移位操作符（>>）则按照操作符右侧指定的位数将操作符左边的操作数向右移<br>
“有符号”右移位操作符使用“符号扩展”；若符号位正，则在高位插入0；若符号位负，则在高位插入1。<br>
java中增加了一种“无符号”右移位操作符（>>>）,他使用“零扩展”；无论正负，都在高位插入0。<br>
> 5<<2 等于20<br>
> 5的二进制是   00000000 00000000 00000000 00000101<br>
> 左移两位是    00000000 00000000 00000000 00010100<br>

> 5>>2 等于 1<br>
> 5的二进制是   00000000 00000000 00000000 00000101<br>
> 右移两位      00000000 00000000 00000000 00000001<br>

> -5>>2 等于 -2<br>
> -5的二进制是   11111111 11111111 11111111 11111011<br>
> 右移两位       11111111 11111111 11111111 11111110<br>
> 转为反码       11111111 11111111 11111111 11111101<br>
> 转为原码       10000000 00000000 00000000 00000010<br>

> -5>>>2 等于 1073741822<br>
> -5的二进制是   11111111 11111111 11111111 11111011<br>
> 右移两位（正数:原码）   00111111 11111111 11111111 11111110<br>

如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，它们会被转为int类型，并且得到结果也是一个int类型的值，
只有数值右端的底5位才有用，这样可防止我们移位超过int类型所具有的位数，（因为2的5次方位为32，而int类型只有32位）。
若对一个long类型的数值进行处理，最后得到结果也是long类型，此时只会用到数值右端的底6位，以防止移位超过long类型数值具有的位数。

移位”可与“等号”（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指定的位数，再将得到的结果赋值给左边的变量。
但在进行“无符号”右移位结合赋值操作时，可能会遇到一个问题，如果对byte或short值进行这样的移位运算，得到的可能不是正确的结果。
他们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

### 二进制与十进制互相转换
#### 十进制负数转换为二进制的方法为：
> 将十进制转换为二进制数
> 对该二进制数求反。
> 再将该二进制数加1.

#### 二进制转换为十进制的方法为：
> 计算机中的整数是用补码存储的，最高位为符号位,C语言也遵从同样的规则。如果最高位为0则为正数，求值的时候，直接转为10进制即可。
> 最高位如果为1代表为负数，求值的时候，需要先把二进制的值按位取反，然后加1得到负数绝对值(相反数)的二进制码，然后转为10进制，加上负号即可。

### 窄化转换与扩展转化
> Java语言提供了八种基本类型<br>

  基本类型   | 所占空间(bit) |	                   取值范围 	                     |  包装类
------------|--------------|-----------------------------------------------------------|--------------
boolean     |       1      |                      false/true  	                       |  Boolean
char 	    |      16      |     	       '\u0000' ~ '\uffff' 	               |  Character
byte 	    |       8      |        	          -128 ~ 127 	                       |  Byte
short       | 	   16      |                    -2^15 ~ 2^15-1   	               |  Short
int 	    |      32      |                    -2^31 ~ 2^31-1      	               |  Integer
long 	    |      64      |                   	-2^63 ~ 2^63-1 	                       |  Long
float 	    |      32      |        	-3.40292347E+38 ~ +3.40292347E+38  	       |  Float
double 	    |      64      | -1.79769313486231570E+308 ~ +1.79769313486231570E+308     |  Double

#### 隐式转换（从低级到高级），又叫扩展转换，不会丢失信息，不需要显式进行转换。
#### 强制转换（从高级到低级），又叫窄化转换，可能丢失信息，需要显式进行转换。

基本类型  |	可隐式转换成的类型（从低级到高级排列）
---------|------------------------------------
char 	 |  	int，long，float，double
byte 	 |  	short，int，long，float，double
short 	 |	int，long，float，double
int 	 |   	long，float，double
long 	 |   	double
float 	 |	double
> 强制转换可以将任何基本类型转换成其他基本类型，但是boolean除外，它不能转换。

### 截尾和舍入
>在执行窄化转换时，必须注意截尾与舍入问题。例如，如果将一个浮点值转换为整数值，Java会如何处理呢？在下面的示例中可以找到答案，
>> （int）0.7 结果：0<br>
>> （int）0.4 结果：0<br>
>> （int）0.7f 结果：0<br>
>> （int）0.4f 结果：0<br>

> 因此，在将float或double转换为整型值时，总是对该数字执行截尾。如果想要得到舍入的结果，就需要使用java.lang.Math中的round()方法，例如
>> Math.round(0.7)结果：1<br>
>> Math.round(0.4)结果：0<br>
>> Math.round(0.7f)结果：1<br>
>> Math.round(0.7f)结果：0

### 类型提升
> 如果对基本数据类型执行算术运算或按位运算，大家会发现，只要类型比int小（即char、byte、short），那么在运算之前，这些值会自动转换为int。
> 这样一来，最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转换（既然把结果赋值给较小的类型，就可能出现信息丢失）。
> 通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。如果将一个float值与一个double值相乘，结果就是double；
> 如果将一个int和一个long值相加，结果为long

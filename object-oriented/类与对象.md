## 类与对象
`万物皆对象`。现实世界中，我们周围有很多对象，如车，狗，人等，这些对象都有自己的状态与行为。<br>
例如一条狗：状态有：名字，颜色，品种，行为有：叫，跑，吃骨头。<br>
软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。<br>
在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。

`对象`是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。<br>
`类`可以看成是创建Java对象的模板。类之中定义的是属性和行为（方法）。<br>
类是对象的模板，对象是类的实例。类只有通过对象才可以使用，而在开发之中应该先产生类，之后再产生对象。类不能直接使用，对象是可以直接使用的。

### 抽象类(使用abstract修饰符来定义)
抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。<br>
对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，<br>
那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。<br>

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>
由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。<br>
含有抽象方法的类必须申明为抽象类<br>
抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类<br>
abstract关键字和哪些关键字不能共存?<br>
> final：被final修饰的类不能有子类（不能被继承）。而被abstract修饰的类一定是一个父类（一定要被继承）。
> private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写,而抽象方法出现的就是需要被复写。
> static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。可是抽象方法运行没意义。

### 接口(使用interface来修饰)
接口，英文称作interface，在软件工程中，接口泛指供别人调用的方法或者函数。从这里，我们可以体会到Java语言设计者的初衷，它是对行为的抽象。
在Java中，定一个接口的形式如下：
```
[public] interface InterfaceName {

}
```
接口中可以含有 变量和方法。但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，
用private修饰会报编译错误），而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），
并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别，
接口是一种极度抽象的类型，它比抽象类更加“抽象”，并且一般情况下不在接口中定义变量。

要让一个类遵循某组特地的接口需要使用implements关键字，具体格式如下：
```
class ClassName implements Interface1,Interface2,[....]{
}
```
可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。

### 抽象类和接口的区别
语法层面上的区别<br>
　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；<br>
　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；<br>
　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；<br>
　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br>
设计层面上的区别<br>
    1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，
    2）抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。
    什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，
    如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。
    而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。
    也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；
    而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
    门和警报的例子<br>
    门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：<br>
```
abstract class Door {
    public abstract void open();
    public abstract void close();
}
```
或者:<br>
```
interface Door {
    public abstract void open();
    public abstract void close();
}
```
但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：<br>
　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；<br>
　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。<br>
　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，
    而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，
    包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。
```
interface Alram {
    void alarm();
}

abstract class Door {
    void open();
    void close();
}

class AlarmDoor extends Door implements Alarm {
    void oepn() {
      //....
    }
    void close() {
      //....
    }
    void alarm() {
      //....
    }
}

